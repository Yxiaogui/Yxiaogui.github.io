{"pages":[{"title":"","text":"小目标： 写16篇weekly 作为开始用blog记录自己的开发之路的开始，这个目标不算大，但希望开个好头，然后坚持下去。因为并不能一上来写blog就可以做到言之有物，给人启发。因此weekly的主要内容从以下维度展开：Tips(每周开发问题)、小结(小感悟)。下一个小目标见，20191013晚10点","link":"/about/index.html"},{"title":"所有标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"打卡01","text":"Algorithm： 本周leetcode算法：两数之和。ps:学校的算法都还给老师了，所以要从最简单的算法训练开始.本周学习的算法是两数之和. Review: 本周还没看是看英语文章 Tip: 本周学习到的技巧、知识点有： CSS: html为网页构建基本的结构，而css定义了他们的外观 定义构造器的方式有：根据元素、类Class、上线文、状态等，Class的前缀是. id的前缀是# 关于盒子模型的认识，常用的参数有：padding(内边距)、border、margin、width、height、float、position、left、right等。常写app的界面布局，对于盒子模型关于父视图的认知还是有点不一样的，之前关注superview、subview等布局样式，现在需要关注left、right、float等 文档流很少关注的元素的高，高度大部分都是自动适配的，如果需要元素至少具有某一种特地高度，可以设置min-height 、max-height,同时相对应的有min-width、max-width swift 本周感受最大的是学习了swift的函数方法的传参、默认值、返回值等，总体感觉比OC简单 方法名是以func开头，区别于oc 方法传入参数的是先书写形参在写实参,返回参数可以直接书写以-&gt;开头，同时可以返回多个参数，很方便，一个字：爽。 1234567891011121314151617181920212223242526func greet(person :String) -&gt; String { let greeting = \"Hello, \" + person + \"!\" return greeting} func isArray(array :[Int]) -&gt; (min :Int, max :Int) {// 判空处理 if array.isEmpty { return (0,0) } var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] { if value &lt; currentMin { currentMin = value } else if value &gt; currentMax { currentMax = value } } return (currentMin, currentMax) }// 调用如下let bounds = tom.isArray(array: [1,2,2,3545,899])print(bounds.max)print(bounds.min) 方法可以社会传入参数的默认值 123456func isDefaultString(defalutis :String = \"DASAN\") -&gt; String { return defalutis}// 调用如下let tom = Tom()print(tom.isDefaultString()) Flutter 本周配置了flutter的环境：在配置环境是需要注意的问题有： 配置本地flutter路径：macos配置的flutter路径 ： /Users/haixin/flutter/flutter，最终配置的路径地址为：export PATH=/Users/haixin/flutter/flutter/bin:$PATH 路径打开、启动的方式为： 12open ~/.bash_profilesource .bash_profile 创建flutter项目的命令有： 123flutter create flutterappcd flutterappflutter run 极客时间 ios专栏 本周专栏从大方面来说讲了两个方面：代码的静态分析、app的无侵入埋点 代码静态分析：xcode自带有静态分析工具analyze,通过静态分析语法，可以找到代码层面的问题如内存泄露，同时也介绍了其他的三种工具：oclint、infer、clang.这三个工具都是clang库开发的。自己尝试安装、编译了infei,扫面了自己的代码。 埋点与无侵入埋点：无侵入埋点指的是在不触碰业务逻辑、高度解耦的情况下尝试对app的页面跳转、点击事件进行监控，来降低线上bug问题的处理难度。常见的方式有runtime、 category. Share: 一下你内容不用看 之前的学习都是无意识的学习，所谓的无意识的学习就能学多少，学多少，这种真的是既浪费时间，有浪费空气。","link":"/passages/20190330/"},{"title":"ARTS打卡打卡03","text":"本周小结: OC: MQTT： 解释： MQTT(消息队列遥测传输)是ISO 标准(ISO/IEC PRF 20922)下基于发布/订阅范式的消息协议。它工作在 TCP/IP协议族上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的发布/订阅型消息协议，为此，它需要一个消息中间件 。 本次项目用到mqtt主要使用在k线绘制，订阅K线实时数据、买卖盘数据等。 用法： 用到的第三方库是阿里推荐的MQTTClient。常规参数配置如下： 12345678910111213141516171819202122232425262728- (MQTTCFSocketTransport *)transport{ if (!_transport) { _transport = [[MQTTCFSocketTransport alloc] init]; _transport.host = @&quot;your host&quot;; _transport.port = your port; } return _transport;}- (MQTTSession *)session{ if (!_session) { _session = [[MQTTSession alloc] init]; _session.userName = @&quot;your userName&quot;; _session.password = @&quot;your password&quot;; _session.clientId = @&quot;you clientId&quot;; _session.delegate = self; } return _session;}//连接- (void)connectMqtt{ self.session.transport = self.transport; [self.session connectWithConnectHandler:^(NSError *error) { if (!error) { [self.session subscribeToTopic:self.topicName atLevel:MQTTQosLevelExactlyOnce]; } }]; } 易错点： mqtt需要维持重连的。看了网上的文档有两种常规的方式。1：KVO即观察session的status；2.通过定时器，判断mqtt的状态，如果断开连接就重连。通过第一种方法观察不到status的变化，导致不能及时判断状态，因此选择了第二张方式。 mqtt关闭。需要设置self.session = nil。如果不设置只调用[self.session disconnect]，会看到mqtt日志在一直打印。因此完整的关闭mqtt的代码如下： 1234567- (void)disconnectMqtt{ [self.session unsubscribeTopic:self.topicName]; [self.session disconnect]; self.session = nil; [self.timer invalidate]; self.timer = nil;} K线： k线主要的作用是反应盘口大势状态和价格的信息，通常绘制k线需要的数据有：最高价、最低价、开盘价、收盘价、日期、成交量。 单个蜡烛图的绘制： 绘制k线首先需要了解：UIBezierPath、CAShapeLayer。其中UIBezierPath指定了蜡烛图的大小位置，CAShapeLayer根据路径将蜡烛图绘制在layer上。以下是一个蜡烛图的绘制： 12345678910CGRect candleFrame = CGRectMake(313.5, 160, 5,20); UIBezierPath *path = [UIBezierPath bezierPathWithRect:candleFrame];[path moveToPoint:CGPointMake(316, 103)];[path addLineToPoint:CGPointMake(316, 160 + 20 + 7)];CAShapeLayer *layer = [CAShapeLayer layer];layer.path = path.CGPath;layer.lineWidth = 1.0f;layer.strokeColor = [UIColor redColor].CGColor;layer.fillColor = [UIColor redColor].CGColor;[self.view.layer addSublayer:layer]; web端与移动端数据问题： 由于这个项目是是先开发web端先定版本，导致在移动端在使用K线数据是需要沿用web使用的数据结构。 121.web端使用数据按照日期倒叙的，移动端需要自己手动逆序数据。2.mqtt订阅主题数据的时间维度问题：每次订阅都会给出全量的时间维度数据即：1分钟、5分钟、15分钟、1小时、4小时......,每次想获取数据增量都需要遍历自己查找。 k线实时绘制： 用消息队列就是K线可以实时绘制，提供准确的交易信息。在处理K线实时绘制是的一个错误的认识：每次拿到K线数据就替换之前的数据开重新绘制界面。通过对比火币的K线图发现，火币的1分钟蜡烛图只会重复绘制最后一个蜡烛图，同时实施修改蜡烛图的颜色(蜡烛图的颜色表示涨跌)，下一分钟在新增一个蜡烛图。同理5分钟、15分钟的维度也是这样绘制的。因此要以时间为参考指标来判断是否需要新增数据，代码如下： 12345678NSString *timeString = dict[@&quot;time&quot;];if ([timeString isEqualToString:oldDict[@&quot;time&quot;]]) { [self.oldklineModels replaceObjectAtIndex:0 withObject:dict]; [self.timeTypeArray addObject:dict];}else{ [self.oldklineModels insertObject:dict atIndex:0]; [self.timeTypeArray addObject:dict];} GCD: 常用： 1234567dispatch_async(dispatch_get_global_queue(0, 0), ^{ // 处理耗时操作的代码块... //通知主线程刷新 dispatch_async(dispatch_get_main_queue(), ^{ //回调或者说是通知主线程刷新， }); }); 12345678+ (instancetype)sharedInstance { static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance;} 什么是GCD： GCD是异步执行任务的技术之一，开发者只需要定义想要执行的任务并追加到适当的Dispatch Queue内，GCD就能生产必需的线程并计划任务执行。GCD 通过简单的方式实现了复杂的多线程编程。 ARTS: 算法： 极客时间： ios自动布局： 常用： 关不布局，最开始的时候用frame,慢慢的随着屏幕尺寸的不断新增，自动布局便成了需要被关注的点。常用的自动布局库有：Masonry、SDAutoLayout、SnapKit。其次需要了解两个单位pt、px. 学习： 1997年，Auto Layout用到的布局算法Cassowary出现。 2011年，苹果将Cassowary算法用到自动布局引擎Auto Layout。 Auto Layout的核心：Layout Engine布局引擎系统，主导整个页面布局。","link":"/passages/20190413/"},{"title":"ARTS打卡02","text":"TIP： 极客时间： Vue: Vue cli致力于将vue生态中的工具基础标准化，他讲确保了各种构建工具能够基于智能的默认配置即可稳衔接，这样就可以专注于撰写应用，而不是纠结于配置。 Vue组件的核心概念：属性、时间、插槽。属性是单项事件流，不能再组件改变父组件传入的值。 同时学习了自定义组件，通过props传参数，点击事件回调参数等。 1234//创建vue项目1.vue create vueapp2.cd vueapp3.npm run serve OC: App启动： 首选需要了解的是：app的启动分为冷启动、热启动。app的启动主要分为三个阶段：1.main()函数执行前即pre-main()；2.main()函数执行后；3；首屏渲染完成后。 那么main()函数执行之前app 做了哪些事情呢： 123456789101.加载可执行文件,(app的.o文件)2.加载动态链接库，进行rebase指针调整和bind符号绑定。3.objc运行时的初始化处理，包括objc相关类的注册、category注册、selector唯一性检查等4.初始化，包括执行+load()方法，attribute((constructor))修改的函数的跳转、创建c++静态全局变量。//相应的对于这个阶段启动的速度优化方法有：1.减少动态库加载。2.减少加载启动后不会去使用的类或者方法3.+load()方法里面的内容可以方法首屏渲染完成之后再执行，或者使用+initialize()方法替换掉。4.控制c++全局变量的数量。//同时去看了苹果开发者大会的视频，关于性能优化之后的建议是：切换成swift，因为它足够优秀。 二维码图片保存相册: 第一种： 1234567891011#import &lt;Photos/PHPhotoLibrary.h&gt;#import &lt;Photos/PHAssetChangeRequest.h&gt;[[PHPhotoLibrary sharedPhotoLibrary]performChanges:^{ [PHAssetChangeRequest creationRequestForAssetFromImage:image]; } completionHandler:^(BOOL success, NSError * _Nullable error) { if (error) { [BaseLoading showOnlyText:@&quot;保存失败&quot;]; } else { [BaseLoading showOnlyText:@&quot;保存成功&quot;]; } }]; 第二种： 12345UIGraphicsBeginImageContext(self.qrImage.size);[self.qrImage drawInRect:CGRectMake(0, 0, self.qrImage.size.width, self.qrImage.size.height)];self.qrImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();UIImageWriteToSavedPhotosAlbum(self.qrImage, nil, nil, NULL); 测试发现通过[UIImage imageWithCIImage:outImage]生产的图片需要需要第二种方法才能保存到相册。 App项目架构-VIEW： 之前很少关注项目架构、代码的统一性问题；了解了设计模式代码缺写的还是很不漂亮。现在在对已有项目作调整，都是欠下的，现在需要补上。 1234561.#pragma mark life &amp;&amp; cycle2.#pragma mark - Table view data source3.#pragma mark - customeview delegate4.#pragma mark - viewmodel kvo5.#pragma mark - getters &amp;&amp; setters6.为了语义上的好理解，所有常见subview方法为customUI或者buildUI选其中之一 除了视图层的规范还需要关注网络层、缓存层、以及第三方库的管理，这个项目可能是最后一个oc项目了。 Swift: 代理书写： 1234567891011//创建代理protocol NewViewControllerDelegate { func testCallBackFunc(callName:String)}//使用代理 var delegate: NewViewControllerDelegate? @objc func clickEventTap() { if self.delegate != nil { delegate?.testCallBackFunc(callName: \"nihao\") } } CSS： 个人很关注css布局、定位，因为移动端上使用的autolayout有比较明显的父视图，再布局是很清楚的知道superview、subview。css在这方面的就显得比较弱，但也不是不可理解。 12345postion的6个属性：1.static(默认)静态定位；2.relative相对定位；3.absolute绝对定位；4.fixed固定位置跟绝对定位相似；5.sticky;6.inherit.偏移量:top、right、bottom 、leftfloat属性：left 、right、 none默认值，不浮动、 inherit继承父元素的浮动属性浮动会脱离正常的文档流布局，会吸附在父容器的左边或者右边等。清除浮动clear三个值：left、right、both 看了书里面对H5的布局称为容器，移动端称为视图。其实作为渲染的View来说两个的称谓可以统一。 Share: 这周看了村上春树的我的职业是小说家，里面提到关于自己没有得到芥川奖的描述总结下来应该是不高估自己、心态平和、关注自己创作。","link":"/passages/20190407/"},{"title":"swift请求","text":"Alamofire 请求简单封装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import UIKitimport Alamofireimport SwiftyJSONprotocol HTTPProxyDelegate { func httpProxySuccess(msg:String,data:NSDictionary) func httpProxyfailure(msg:String)}class HTTPProxy: NSObject { public var isPost :Bool! public var isFile :Bool! public var path = \"\" public var hosturl = \"\" private var urlString = \"\" public var parameters = [String :Any]() var delegate :HTTPProxyDelegate? let headers = [\"Sign\":\"ios\",\"Authorization\":\"1234567890\"] public func loadData() { urlString = hosturl + path if isPost { postRequest() }else{ getRequest() } } private func getRequest() { Alamofire.request(urlString, method:.get, parameters: parameters, encoding: URLEncoding() as ParameterEncoding, headers: headers).responseJSON { (response) in print(\"get request \") } } private func postRequest() { Alamofire.request(urlString, method:.post, parameters: parameters, encoding: URLEncoding() as ParameterEncoding, headers: headers).responseJSON { (responese) in if let value = responese.result.value { let jsonData = JSON(value) let code = jsonData[\"Code\"].stringValue let msg = jsonData[\"Msg\"].stringValue let data = jsonData[\"Data\"].dictionary if (code == \"200\"){ if self.delegate != nil{ self.delegate?.httpProxySuccess(msg: msg, data: data! as NSDictionary) } }else if (code == \"202\"){ if self.delegate != nil{ self.delegate?.httpProxyfailure(msg: msg) } }else{ if self.delegate != nil{ self.delegate?.httpProxyfailure(msg: msg) } } }else{ if self.delegate != nil{ self.delegate?.httpProxyfailure(msg: \"网络错误\") } } } }} 请求调用 1234567891011let httpproxy = HTTPProxy()httpproxy.isPost = truehttpproxy.path = \"index/investlist\"httpproxy.delegate = selfhttpproxy.loadData()func httpProxyfailure(msg:String){}func httpProxySuccess(msg:String,data:NSDictionary){} 项目一直用的OC开发的，swift作为趋势，慢慢的需要对项目代码做迁移，OC请求封装跟swift的不同点在于：oc用的是block回调的方式，swift选择的代理。","link":"/passages/20190514/"},{"title":"React Native","text":"移动开发现状： 1231. 原生开发2. 混合开发3. 跨平台开发 技术选型： 1231.Native2.Native + H5 (1.原生与H5通过jsbridge交互，双发需要提前约定相互调用点击事件Key；2.原生通过富文本的方式渲染H5字符串)3.React-Native 、Weex 、Flutter &lt;!--more--&gt; 跨平台的优势 一次编写，多平台使用，试图解决安卓、ios从交互到UI的统一。 React-Native 、Weex 、Flutter对比 1.React Native 基于React 的，而React 是Facebook用户构建用户界面的Javascript库 2.Weex基于Vue的，而Vue是阿里开源的渐进式 JavaScript 框架 3.Flutter是谷歌开源的响应式框架,开发语言为Dart 4.以上可以看出RN、Weex对于前端工程师进入移动开发领域是相对友好的，而Flutter对于移动开发者、前端开发者都是有学习成本的。 5.从社区的活跃度来看RN高于Weex,而Flutter刚刚起步，但是也得到了社区的支持，因为RN是通过调用原生系统的UI组件来渲染页面，在不同的开发平台实现效果会有所偏差，毕竟是两个操作系统。而Flutter是是自有的UI框架，更接近于实现跨平台的理想。 React Native VS 原生 1React Native的设计理念：既拥有Native的用户体验、又保留React的开发效率 1234567Native的优势：1.Native的原生控件有更好的体验2.Native有更好的手势识别3.Native能实现更丰富细腻的动画效果，归根结底是现阶段Native具有更好的人机交互体验Native劣势1.Native开发成本更高 综上对于开发团队在对于项目技术选型的时候需要做好平衡点：追求开发效率，还是原生体验。以此会带来对移动项目架构新的设想、实践。 React Native宣言： “Learn once, write anywhere” React Native介绍： React Native 是一个 JavaScript 的框架，用来撰写实时的、可原生呈现 iOS 和 Android 的应用。它是基于 React 的，而 React 是 Facebook 的用于构建用户界面的 JavaScript 库，但是 React Native 不是给浏览器解释的，而是为移动平台。换句话说：如果你是一名 web 开发者，你可以使用熟悉的框架和单一的 JavaScript 代码库，即 React Native来撰写清晰的、高效的移动应用。 React Native应用原理： 在JavaScript中用React.js抽象操作系统的原生UI组件，继而代替DOM元素来渲染，比如使用&lt;View&gt;取代&lt;div&gt;，使用&lt;Image&gt;替代&lt;img&gt;等。在后台，React Native运行在主线程之外，而在另一个专门的后台线程里运行JavaScript引擎，两个线程之间通过异步消息协议来通信。 React Native VS Flutter: React Native开发工具 VSCode、WebStorm; 推荐使用VSCode VSCode需要安装的插件 React Native Tools：微软官方出的ReactNative插件 path Intellisense：文件路径提示补全 Reactjs code snippets：react的代码提示 React Developer Tools：浏览器安装调试扩展 学习知识准备： 了解一些基本的 React 的概念，比如 JSX 语法、组件、state状态以及props属性 JSX语法： JSX就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到&lt;，JSX就当HTML解析，遇到{就当JavaScript解析。 jsx语法：https://www.cnblogs.com/zourong/p/6043914.html 示例 12345xml网上示例：&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget the meeting!&lt;/body&gt; 1234js写法var child1 = React.createElement('li', null, 'First Text Content');var child2 = React.createElement('li', null, 'Second Text Content');var root = React.createElement('ul', { className: 'my-list' }, child1, child2); 1234567等价于(JSX写法)var root =( &lt;ul className=\"my-list\"&gt; &lt;li&gt;First Text Content&lt;/li&gt; &lt;li&gt;Second Text Content&lt;/li&gt; &lt;/ul&gt;); props、State 我们使用两种数据来控制一个组件：props和state。props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。 对于需要改变的数据，我们需要使用state。 一般来说，你需要在 constructor 中初始化state（译注：这是 ES6 的写法，早期的很多 ES5 的例子使用的是 getInitialState 方法来初始化 state，这一做法会逐渐被淘汰），然后在需要修改时调用setState方法。 props示例： 12345_HomeListCell(item, index) { return ( &lt;HomeListCell name={item.key} index={index}&gt;&lt;/HomeListCell&gt; )} 12345678910111213class HomeListCell extends Component { constructor(props) { super(props); } render() { return ( &lt;View style={styles.listcellView}&gt; &lt;Text style={styles.listcellText}&gt;{this.props.name + this.props.index}&lt;/Text&gt; &lt;/View&gt; ) }} state示例： 要点: 一切界面变化都是状态state变化 state的修改必须通过setState()方法 this.state.likes = 100; // 这样的直接赋值修改无效！ setState 是一个 merge 合并操作，只修改指定属性，不影响其他属性 setState 是异步操作，修改不会马上生效(疑问数据不是实时更新的？) 123456789101112constructor(props) { super(props); this.state = { listData: ['1','2','3'], };}_loadRequest(){ this.setState({ listData: ['3','2','1'], })} 组件： UI组件学习这个需要时间 第三方库集成： 安装： npm install react-native-device-info --save 卸载： npm uninstall react-native-device-info 搜索： https://js.coach/","link":"/passages/20190617/"},{"title":"cocoapods库与库依赖冲突解决","text":"集成TokenCore、web3swift.pod出现了库与库依赖版本的报错问题： 报错信息如下： 123456789101112[!] CocoaPods could not find compatible versions for pod &quot;BigInt&quot;: In snapshot (Podfile.lock): BigInt (= 3.1, = 3.1.0, ~&gt; 3.1) In Podfile: TokenCore was resolved to 0.1, which depends on BigInt (= 3.0.0) web3swift.pod was resolved to 2.1.10, which depends on BigInt (~&gt; 3.1)Specs satisfying the `BigInt (= 3.1, = 3.1.0, ~&gt; 3.1), BigInt (~&gt; 3.1), BigInt (= 3.0.0)` dependency were found, but they required a higher minimum deployment target. 解决的方法如下： fork TokenCore到自己的github 修改 s.dependency &quot;BigInt&quot;, &quot;3.1&quot; 更改pod 'TokenCore'为 pod 'TokenCore', git: 'https://github.com/Yxiaogui/token-core-ios.git', commit: 'c87640c72c1cf1662495cf28a90824c6731f790f' 重新pod install 解决冲突 12pod &apos;web3swift.pod&apos;pod &apos;TokenCore&apos;, git: &apos;https://github.com/Yxiaogui/token-core-ios.git&apos;, commit: &apos;c87640c72c1cf1662495cf28a90824c6731f790f&apos; 参考文章地址： http://ju.outofmemory.cn/entry/150210","link":"/passages/20190703/"},{"title":"制作私有仓库","text":"​ 制作私有仓库的首先需要创建一个仓库地址,名字如XXPods,这个仓库的功能是存储，里面会包换创建的各个模块如(Test-Home)的包地址。 1.创建存储仓库的过程如下： 1231.pod repo add XXPods git@gitee.com:****/XXPods.git2.cd ~/.cocoapods/repos 可以看到已创建的文件3.pod repo push XXPods Test-Home.podspec --allow-warnings 制作好的包更新到自己的仓库地址 2.创建私有仓库过程如下： 123451.创建仓库Test-Home,然后clone到本地2.pod spec create Test-Home, Test-Home.podspec里面会包含包版本号、仓库地址、依赖包、依赖的代码路径等。3.pod lib lint 检测仓库配置是否正确4.pod repo push XXPods Test-Home.podspec --allow-warnings 将制作好的包更新到自己的仓库地址5.使用自己的私有仓库记得在podfile文件里面加入 source &apos;https://gitee.com/****/XXPods.git’ 3.创建仓库的过程中遇到的问题： 1231. 缺少LICENSE，这个可以在很多开源的仓库里看到，复制一份就解决了2. -&gt; Test-Home (0.0.1) - ERROR | [iOS] unknown: Encountered an unknown error (Malformed version number string ) during validation. 解决的方式为：sudo gem install -n /usr/local/bin cocoapods 4.更新仓库 通过以上的步骤我们创建了一个Test-Home的私有库，tag等于0.0.1。可以在原有的基础上更新，但是为了业务兼容性，可能就会需要有多个tag版本同时运行，制作的方式如下 1234561.更新好本次迭代的代码内容2.pod lib lint 检测仓库配置是否正确3.注意注意更新.podspec文件的版本号4.提交代码到git5.创建tag: git tag -a 0.0.2 -m &apos;add 0.0.2&apos; 、 git push origin 0.0.26.pod repo push XXPods Test-Home.podspec --allow-warnings 将制作好的包更新到自己的仓库地址 5.podspec文件内容如下 12345678910111213Pod::Spec.new do |s| s.name = &quot;Test-Home&quot; s.version = &quot;0.0.2&quot; s.summary = &quot;私人pod代码&quot; s.description = &apos;desc test home&apos; s.homepage = &quot;https://gitee.com/****&quot; s.license = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; } s.author = { &quot;张三&quot; =&gt; &quot;123456789@qq.com&quot; } s.platform = :ios, &quot;9.0&quot; s.source = { :git =&gt; &quot;https://gitee.com/*****/Test-Home.git&quot;, :tag =&gt; &quot;#{s.version}&quot; :submodules =&gt; true} s.source_files = &quot;Test-Home/*.{h,m}&quot; s.requires_arc = trueend","link":"/passages/20190704/"},{"title":"20190910","text":"React Native项目编译： React Navigation React Navigation库引入失败的问题，导致各种的报错，具体修复问题见官方文档提示如下：特点：容易混淆是不同版本的link的方式不同。 1231.In your project directory, run yarn add react-native-reanimated react-native-gesture-handler react-native-screens.2.React Native 0.60 and higher:linking is automatic; cd ios、pod install3.React Native 0.59 and lower；react-native link react-native-reanimated、react-native link react-native-gesture-handler、react-native link react-native-screens 编译报错 编译报错内如下，特点：通过react-native run-ios 会提示报错，通过build ios app可以编译通过；错误信息如下： error Failed to build iOS project. We ran &quot;xcodebuild&quot; command but it exited with error code 65. To debug build logs further, consider building your app with Xcode.app, by opening ctranceplatform.xcworkspace. Run CLI with --verbose flag for more details. 123解决方法：clear build folder: &apos;Your Project&apos;/ios/buildreact-native run-ios One-Click: 简介：通过运营商的接口能力直接获取用户的手机的号码。 能力输出：集成三大运营的接口能力做成SDK，以供客户使用。同时开发了One-Click应用发布应该市场，便于大家体现能力。 Tips: 1.React 自定义组件命名需要首字母大写","link":"/passages/20190910/"},{"title":"20190918","text":"React Native: 关于flex 、postion的结合在移动端的布局，在C端App的实践很有效果，十几个页面写完，布局不在困难。 自定义组件 传入参数，后调点击事件： 12345678910111213141516171819202122232425// 以下的自定义组件的为导航栏右侧按钮// 需要注意的是要导入 import PropTypes from &apos;prop-types&apos;;class NavRightTextView extends Component { static propTypes = { title: PropTypes.string, rightButtonClick: PropTypes.func, } static defaultProps = { title: &apos;&apos;, rightButtonClick: PropTypes.func, } _rightButtonClick() { this.props.rightButtonClick() } render() { return ( &lt;TouchableOpacity onPress={() =&gt; this._rightButtonClick()}&gt; &lt;Text style={styles.rightButton}&gt;{this.props.title}&lt;/Text&gt; &lt;/TouchableOpacity&gt; ) } Vue: vue 渐进式框架 关注视图层. 1234567891011121314151617181920212223242526272829&lt;div id=\"app\"&gt; &lt;p&gt;{{mg}}&lt;/p&gt; &lt;input v-on:input=\"inputHandle\"&gt; &lt;p v-bind:title=\"mg\"&gt;{{mg}}&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var msg = 'hello world '; //根实例 启动应用 // 传入一个对象作为参数 //{{}} 模板语法 // vue 绑定事件 /* * 指令 将数据与dom关联 v-bind 预期值是一个表达式 * v-on:事件名=\"表达式\" * */ var app = document.getElementById('app') var vm = new Vue({ // el: app el:'#app', data:{//数据对象 mg:msg, }, methods:{ inputHandle(){ console.log(\"09090\") }, } })&lt;/script&gt; Tips: 123库：方法的封装，以供调用。框架： 一套架构 是一个解决方法，必须要延续使用框架定义的规范。同时要注意框架也是有复杂度的。区别在于控制权在谁手里。","link":"/passages/20190918/"},{"title":"20190911","text":"React 1231.组件化2.单向数据流 ,props state3.虚拟DOM Flex Box 123通过绘制C端首页体会一次，flex布局的魅力,快速的布局瀑布流效果1.flexWrap子组件组件换行方向2.flexDirection决定组件主轴的排列方向 react-navigation 12345678910111213今天比较上头的操作是设置底部tabbar的图片，难点在于接触新的的编程方式容易把之前的经验自动带入，属性赋值操作看起来就没有想象中的那么容易，方法如下：showIcon: trueHomeTab: { screen: HomeNav, navigationOptions: { tabBarLabel: &apos;首页&apos;, tabBarIcon: ({focused}) =&gt; ( focused ? &lt;Image style={styles.iconStyle} source={require(&apos;../Images/home_select.png&apos;)}/&gt; : &lt;Image style={styles.iconStyle} source={require(&apos;../Images/home_normal.png&apos;)}/&gt; ), }, },","link":"/passages/20190911/"},{"title":"第一周weekly","text":"Tips: 1.React Native编译文件导致的编译失败 1234//错误提示error Failed to build iOS project. We ran &quot;xcodebuild&quot; command but it exited with error code 65://处理方法：clear build folder: &apos;Your Project&apos;/ios/build。 2.安卓真机调试：摇晃手机选择Dev，手机连接电脑本地Ip地址，例如：192.168.0.105：8081。 3.父组件向子组件传值通过props方式；子组件向父组件传值：通过props回传，涉及到组件传值，以及点击事件回调。 &lt;!--more--&gt; 4.处理console.log不打印日志的问题：之前index.js文件引入了处理RN项目模拟器显示警告信息代码如下,带来的结果是调试日志打印不出来。 12console.ignoredYellowBox = ['Warning: BackAndroid is deprecated. Please use BackHandler instead.','source.uri should not be an empty string','Invalid props.style key'];console.disableYellowBox = true; 5.8081端口被占用: 1234//错误提示Connection to localhost port 8081 [tcp/sunproxyadmin] succeeded!Port 8081 already in use, packager is either not running or not running correctlyCommand PhaseScriptExecution failed with a nonzero exit code 123//解决方法sudo lsof -i :8081 kill -9 40247 6.props属性的定义错误的提示 12//这个错误出现在将设置图片的地址的props设置为string，编译器warning警告Failed prop type: Invalid prop `bgImage` of type `number` supplied to `MoneyBaseCellView`, expected `string`. 7.ios适配：逻辑分辨率适配、物理分辨率适配。 12逻辑分辨率适配：通常是基于标准机型如：iphone6的等比例尺寸的方法、缩放；另外一种是对于具体屏幕尺寸的准确布局。物理分辨率：指的是同一尺寸的像素点的多少，像素点多，分辨率高，色彩丰富，清晰度高，通常用在图片上:testImage@2x.png、estImage@3x.png。 文摘： 把时间当作朋友: 每天制作你的时间预算。 很多人一生最终一事无成的原因，就是因为他们是脆弱的完美主义者，天真地希望自己可以在这个不完美的世界里完美地生存——所以注定以失败告终。 有趣的事不见得有用呢 如果，你甩甩头，强迫自己理智一些，就会知道，无用的事情，哪怕非常有趣都不应该去做；而有用的事情，哪怕非常无趣，你都应该做。 异类: 罗塞托之谜：当年主流的观点是长寿与否取决于我们是谁—也就是个体的基因，还仰赖个体做出的选择—选择吃什么，选择锻炼多长时间，以及我们受到医疗体系照顾的程度。在此之前，还从来没人从“社区”的角度研究人体健康问题。 那就是超越个人的范围寻找原因—要理解人们所处的文化背景，要考虑他们的家庭和朋友状况，要追踪其家族渊源。人们必须认识到，人类栖身其中的自然环境和社会环境，对人的发展发挥着不可磨灭的作用。 人们通常只想到杰出人士是最优质的种子，但很少想到成材还必须有充足的日照，有深厚肥沃的土壤，有足够的运气躲过兔子和伐木工人。 小结： 本周是第一次开始每晚记录自己当天的时间开销，同时记录Tips(ps:Tips是用来收集当天编码过程中出现问题或者bug的处理方式，这个作用类似于上学是老师让记得错题集)。 时间开销：记录了一周的时间开销，统计了一下当天编码的时间，3个小时左右，其中可见的很多时间都浪费了。 思考：在开始记录时间开销的第三天的时候，自己就等会对前两天的时间开销日志不忙，想着急改变。同时另外一个问题也在脑海形成：记录时间开销的时间会坚持多久？养成一个习惯的时间不会再一周之内快速养成，毕竟人的惰性还是很大的。能意识到自己时间开销浪费的正向作用是，会刺激接下来的一天、两天、三天甚至更长的天数来养成习惯，减少日常浪费时间的时间。 关于高级工程师：昨晚去招聘的网站看了一下招聘需求，看到同样年限大厂需要的是高级前端工程师，不小长需要的是编码的。对我个人的刺激点是怎么才能通向高级前端工程师，这个问题是需要我接下来四个月需要深度思考时间的问题。 第一周weekly。 下周就是国庆假期了，希望自己可以及时给自己充电。","link":"/passages/20190929/"},{"title":"第二周weekly","text":"小结： 19年的国庆节是待在杭州过的，没有回家。原因也很简单，不想被家人催的不耐烦，同时还要装出一副很体谅且无可奈何的表情。成年人的世界没有容易两字，尽可能的给自己营造舒适的生活氛围。个人感觉还是先把自己的生活过来在想其他的事情。 本周最大的收获去看完了ios视频课程，课程学完之后可能帮助我在更加全面的理解大型app的架构思想，以及个个模块的依赖关系。了解了组件化有三种方式：Tagrget-Action、Url-Scheme 、Protocol -class，推荐前两种方式。;了解了日志分级上传，ps:之前很少关注日志上传的模块的问题。在组件化思想指导下要关注以下模块：基础业务模块、日志模块、crash模块、缓存模块。 本周大部分时间还在考虑转型的问题：移动端开发者转型大前端还是后端开发？技术开发的职业生涯会有多久？自己可以做多久不会被淘汰，如果被淘汰自己是否还有其他的技能可以做备用。 其他：本周在家打扫卫生：扫地、拖地、清理汤圆的猫爬架(真的好多猫毛)。 其他假期之后的不愉快的事情都可以解决。","link":"/passages/20191006/"},{"title":"第3周weekly","text":"MacOS 10.15： 本周Mac更新系统遇到的问题： 键盘的中/英切换的按钮，灯不亮了，功能还在，真的是让人不爽。 终端改为zsh,个人还是比较喜欢的，因为有很多主题可以更换，很不错的。 Pod install出错。这个网上的教程很多，更新gem源就好了。 &lt;!--more--&gt; Tips: 以下是本周使用React Native开发遇到的问题： FlatList空数据渲染，ListEmptyComponent这个属性 navigationOptions不能引用this.xxx方法的问题,解决方向如下示例： 123456789101112131415161718192021222324252627282930313233//外部引用let that;class EditAddressViewController extends Component { static navigationOptions = ({navigation}) =&gt; { const params = navigation.state.params; return { title: params.NavTitle, headerRight: ( &lt;NavRightTextView title={'保存'} rightButtonClick={() =&gt; { that._addAddressRequest(); }} /&gt; ), }; }; constructor(props) { super(props); that = this; } _addAddressRequest() {} render() { return ( &lt;View style={styles.container} &lt;/View&gt; ); }} TextInput的使用问题：输入框设置固定宽度可以解决输入内容闪烁的问题、设置默认文本用defaultValue 代替 value。 静态图片的问题：Packager 就会去这个组件所在的文件夹下查找my-icon.png。并且，如果你有my-icon.ios.png和my-icon.android.png，Packager 就会根据平台而选择不同的文件。 你还可以使用@2x，@3x这样的文件名后缀，来为不同的屏幕精度提供图片。 12345// 加载远端图片 &lt;Image source={{uri: this.props.item.PicUrl}}/&gt;// 加载本地图片&lt;Image source={require('../../Images/address_edit_image.png')}/&gt; react-navigation:导航栏反向传参数的问题，示例如下: 123456789101112131415161718192021// B页面--&gt;&gt;A页面反向传参 // B页面代码_coinListTap() { this.props.navigation.state.params.callBack({ CoinId: this.props.item.CoinId, CoinName: this.props.item.CoinName, }); this.props.navigation.goBack(); }// A页面 _callBack(params) { this.setState({ coinName: params.CoinName, coinId: params.CoinId }); } _coinNameTap() { this.props.navigation.navigate('CoinListVC',{callBack:this._callBack.bind(this)}); } 小结： 本周对我个人而言有两个关键词：前端、算法。 前端是必定要涉足的领域，因为是移动端开发入行的，现在的趋势是大前端，为了提高自身的核心竞争力，必须要拥抱js、vue、react。 本周是极客大学算法训练营的预习周，下周正式开始算法的学习，希望努力学习给自己核心竞争力提供支持。努力学习是什么、为什么、怎么做的。","link":"/passages/20191013/"},{"title":"第4周weekly","text":"算法训练营第一周： 本周学习的数据结构数组、链表、队列、栈都是线性表结构。 数组: 关键词：线性表、连续内存 数组是一种线性表数据结构。它是一组连续的内存空间，存储相同类型的数据结构。数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。为了保证内存数据的连续性，数组的插入、删除时间复杂度为O(n)。同时需要注意的是:如果数组插入在末尾那么时间复杂度为O(1),插入在开头，时间复杂度为O(n);同理数组删除末尾的时间时间复杂度为O(1),删除开头的时间复杂度为O(n)。数组的时间复杂的依据是保证数据内存的连续性，是否迁移数据的位置。 &lt;!--more--&gt; 链表： 关键词：不连续、指针、 head指针、tail指针 链表不需要连续的内存，通过指针将一组零散的内存串联起来。常见的链表有：单链表、双向链表、循环链表。每个链表的节点出去存储数据之外，还需要记录链表的的下一个节点的指针。链表的插入、删除的节点的时间复杂度为O(1)，查找的时间复杂度为O(n)。 两个重要的思想： 关键词：时间换空间、空间换时间 对于执行比较慢的程序可以通过消耗跟多内存来进行优化。空间换时间 对于消耗过对内存的程序，可以通过消耗更多的时间来降低内存。时间换空间。 栈： 关键词：先进后出、后进先出、入栈、出栈 栈的典型特点：先进后出、后进先出，线性结构。 队列： 关键词：先进先出、入队、出队 队列的典型特点：先进先出，线性结构。 小结： 本周有一件小事带来的冲击感：生病。 普通的小病可能都不会关注，感冒不想吃药的可以以身体还行为理由多抗几天，实在不行吃两天药也就好了。但是稍微大一点的病在花钱上就会给人有很强烈的挫败感，如果你经历可能会知道医院是需要预付款的。这个时候给我的感觉是原来生活没有Plan-B，自己也没有准备其他的预备方案以应对突如其来的事情。就好比工作时间一样，有的人同样的时间可以卖好多份，而你却只能卖出去一份，甚至还存在卖不出去的情况。一句话总结：自身没有低于风险的能力。 好吧，既然到了这个点就思考一下能不能为自己找到一个Plan-B，如果找到了怎么计划？怎么执行？希望得到什么样的结果？满脸的疑问......","link":"/passages/20191020/"},{"title":"第5周weekly","text":"算法训练营第二周： 哈希表：Hash Table,也叫散列表，根据关键是key、value直接进行访问的数据结构。通过把关键码值到表中一个位置来进行访问，以加快查询的速度，映射的函数成为散列函数，存放记录的数组叫做哈希表（散列表） 二叉树：二叉树遍历：前序遍历（根-左-右）、中序遍历（左-根-右）、后序遍历（左-右-根） 二叉搜索树：是指具有一些特性的二叉树，左子树上所有结点的值均小于它的根节点的值，右子树所有结点的值均大于它的根节点的值。 具有特性，常规的暴力操作是递归、优化操作栈，同属需要注意的是结束条件即何时return，参数校验等。 分治、回溯：本质还是递归，找重复性，分解成多个子问题 &lt;!--more--&gt; CTMediator： 阅读了CTMediator的源码，总结如下： 定义调用目标组件的命名方式如：Target_A、Target_B 定义调用目标组件方法的命名方如：Action_Native、Action_ShowAlert 定义调用外部组件的方式，做CTMediator的分类 目标类的获取方式：NSClassFronString ，String转Class 目标类方法的生成：SEL action = NSSelectorFronString target调用action 组件、模块之间的调用依赖为软编码 CTMediator对调用不到方法的做的容错处理 小结： weekly的第五周了，明显的感觉到坚持写是很困难的事情。 之前我一直在对自己做实验，每天坚持写日计划，抛弃工作的时间不算，自己的自律性不是特别好，因为每天的计划都没有全部完成，真是应了那就那句话，空闲时间学习真的是很反人性的操作。之前晚上有个很有名的段子讲的是马云教育孩子的上网吧的问题,给300块钱去网吧，之后回来写一写上网的好处，类比自己特别想写一个周末不看书刷视频、刷微博的好处，我想我能给出的答案是看视频、刷微博这件事是轻松的，不费脑子的，好处没有，只会增减屏幕使用时间。 理想很丰满，现实很骨感。","link":"/passages/20191027/"},{"title":"第6周weekly","text":"算法训练营第六周： 贪心算法Greedy: 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择,从而希望导致结果是全局最好或最优的算法。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退，动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择,有回退功能。 二分查找： 目标函数单调性（单调递增或者递减） 存在上下界（bounded） 能够通过索引访问（index accessible） 深度优先搜索DFS、广度优先搜索BFS 每个节点都要访问一次 每个节点仅仅要访问一次 对于节点的访问顺序不限 Tips: 安装infer对代码进行静态分析。 了解了链接器是怎么工作的，这个可以用逻辑图描述一下（欠一个逻辑图）。 小结： 本周最大收获是陪家人在医院做手术的过程，最大感受是体悟痛苦，以及怎样做得更好。你会发现很多人在医院准备的椅子上坐着等待着，那样子很像课堂上认真听讲的学生，好好学习，时刻准备着被医生叫到。 大概的过程如下：术前检查准备、手术室外等待、术后医生确认、术后恢复等。作为陪护的人员，最煎熬的其实是等待，因为进不去，所有的需要的东西都只能递进去包括吃的。也因为进不去你会比做手术的人还要紧张，会担心一些不被期望发生的事情。不想让自己变成医院的常客，等待的过程太过压抑了。","link":"/passages/20191103/"},{"title":"第7周weekly","text":"Tips: react-navigation4.0保持ios、android导航栏标题居中，push样式一直的方式： 123456789import StackViewStyleInterpolator from &apos;react-navigation-stack/src/views/StackView/StackViewStyleInterpolator&apos;; //导航ios、android保持一直headerMode: &apos;screen&apos;,transitionConfig: () =&gt; ({ screenInterpolator: StackViewStyleInterpolator.forHorizontal,}),//标题居中headerLayoutPreset: &apos;center&apos;, 小结： 本周两件事情，家人的手术经过一周时间的恢复，结果很不错。其二就是某些具体的原因拒绝了一位小朋友的购物需求，希望过年的时候可以补偿这位小朋友。","link":"/passages/20191110/"},{"title":"第8周weekly","text":"Tips: 关于fetch请求body为formdata的数据处理问题，注意安卓、iOS的数据方式不一样。对于RN开发的都是基于ios先开发，然后对于andriod进行改造的。 Bug点在于所有的请求iOS端是完全没问题的，andriod的get请求也没问题，但是post数据抓包显示没有参数传递： 12345678910111213// data为json数据 json 转 fromdata// ios端let formData = new FormData();Object.keys(data).forEach(key =&gt; { formData.append(key, data[key]);});//andriod端var serializeJSON = function (data) { return Object.keys(data).map(function (keyName) { return encodeURIComponent(keyName) + '=' + encodeURIComponent(data[keyName]) }).join('&amp;');} 小结： 希望一起都慢慢的好起来。","link":"/passages/20191117/"},{"title":"第9周weekly","text":"Tips: react-navigation 导航栏隐藏： 12345static navigationOptions = ({navigation}) =&gt; { return { header: null }; }; FlatList实现类瀑布流效果： 注意高度需要保持一致。Warning: flexWrap:wrap`` is not supported with the VirtualizedList components.Consider using numColumns with FlatList instead. 123456789101112131415161718192021222324252627const BaseCellWidth = Dimensions.get(&apos;window&apos;).width / 2.0;render() { return ( &lt;FlatList data={this.state.listData} renderItem={({item}) =&gt; &lt;FoodsBaseListView styles.foodsListBase/&gt;} keyExtractor={(item, index) =&gt; item + index} contentContainerStyle={styles.listViewStyle} numColumns={2} horizontal={false} /&gt; );}const styles = StyleSheet.create({ listViewStyle: { flexDirection: &apos;column&apos;, }, foodsListBase: { backgroundColor: &apos;white&apos;, width: BaseCellWidth, alignItems: &apos;center&apos;, marginTop: 10, height: 220, },}); 安卓打release包时报错与处理： 安卓打包阿里云oss库报错：Task :aliyun-oss-react-native:verifyReleaseResources FAILED FAILURE: Build failed with an exception.处理方案：https://github.com/aliyun/aliyun-oss-react-native/issues/49 Task :app:bundleReleaseJsAndAssets FAILEDFAILURE: Build failed with an exception.What went wrong: Execution failed for task ':app:bundleReleaseJsAndAssets'.处理方案：https://github.com/facebook/metro/issues/288 小结： 本周RN编译的移动端(andriod、ios)项目正式切入线上环境，期待下周的发布与审核。","link":"/passages/20191124/"},{"title":"第10周weekly","text":"Tips: 溯源iOS-App上线： 123456第一次审核失败原因及修复：1.修改相机、定位权限描述文本：此App会在扫描溯源二维码服务中访问您的相机权限、此App会在扫描溯源二维码服务中访问您的定位权限2.预览图与实际效果不符合，更换新版预览图3.应用评分不合适，因为商品介绍有白酒的图片，导致需要修改应用评分。第二次审核看了一下审核记录从审核到结束三分钟，真的很快了。 小结： 第一次全用React Native构建的App发布。","link":"/passages/20191201/"},{"title":"第11周weekly","text":"Tips: 本周找时间敲了一遍菜鸟教程的Node.js的代码，对于Node.js有了初步的了解。 在连接数据库的时候出现了问题：Client does not support authentication protocol requested by server 处理方法如下： 11、alter user &apos;root&apos;@&apos;localhost&apos; identified with mysql_native_password by &apos;********&apos;; 小结： 下周开始一个新的任务，每天打卡至少一道算法题目，先坚持一个月的。","link":"/passages/20191208/"},{"title":"20191209-algorithm-01","text":"两数之和： 解法01: 1234567891011//暴力求解//时间复杂度O(n^2)var twoSum = function(nums, target) { for(let i = 0;i &lt; nums.length;i ++){ for(let j= i + 1;j &lt;nums.length;j ++){ if(nums[i] + nums[j] === target){ return [i,j] } } }}; 解法02： 123456789101112// 时间复杂度O(n)var twoSum = function(nums, target) { let map = new Map() for(let i = 0;i &lt;nums.length; i++){ let next = target- nums[i] if(map.has(next)){ return [map.get(next),i] }else{ map.set(nums[i],i) } }};","link":"/passages/20191209-algorithm-01/"},{"title":"20191210-algorithm-02","text":"旋转数组： 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 解法01： 12345678910111213//暴力求解//时间复杂度O(n^k)var rotate = function(nums, k) { let temp,previous for (let i = 0; i &lt; k; i++){ previous = nums[nums.length - 1] for(j = 0; j &lt;nums.length; j ++){ temp = nums[j] nums[j] = previous previous = temp } }}; 解法02： 123456789//该解法需要了解数组的两个方法：//pop()删除并返回的数组的最后一个元素//unshift()向数组的开头添加一个或者多个元素，并返回新的长度//时间复杂度O(n)var rotate = function(nums, k) { for(var i=0;i&lt;k;i++){ nums.unshift(nums.pop()) }}; 解法03： 12345678910//splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。/** arrayObject.splice(index,howmany,item1,.....,itemX) index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目*/var rotate = function(nums, k) { k %= nums.length nums.unshift(...nums.splice(-k, k));};","link":"/passages/20191210-algorithm-02/"},{"title":"20191211-algorithm-03","text":"题目：合并两个有序链表 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 123&gt; 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4&gt; 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4&gt; 解法01 1234567891011121314151617181920/*如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。*/// 递归var mergeTwoLists = function(l1, l2) { if (l1 == null){ return l2 } else if (l2 == null){ return l1 } else if (l1.val &lt; l2.val){ l1.next = mergeTwoLists(l1.next,l2) return l1 }else { l2.next = mergeTwoLists(l1,l2.next) return l2 }}; 解法02： 1234567891011121314//创建一个新的节点var mergeTwoLists = function(l1, l2) { if (l1 == null) return l2 if (l2 == null) return l1 var current = new ListNode('') if(l1.val &lt; l2.val){ current.val = l1.val current.next = mergeTwoLists(l1.next,l2) }else{ current.val = l2.val current.next = mergeTwoLists(l2.next,l1) } return current }; 知识点： 数组、链表对比： 数组需要一块连续的内存空间 链表不需要一块连续的内存空间，它是通过指针将一组零散的内存块串联起来的。内存块成为链表的“结点”，为了链表的结点串联起来，每个链表的结点出来存储数据之外，还需要记录链上的下一个结点的地址，把记录下一个结点地址的指针叫做后继指针next. 链表结构：单链表、双链表、循环链表。 时间复杂度 数组 链表 插入、删除 O(n) O(1) 随机访问 O(1) O(n)","link":"/passages/20191211-algorithm-03/"},{"title":"20191212-algorithm-04","text":"合并有序数组： 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中*，*使得 num1 成为一个有序数组。 123456示例：输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 解法01 12345678//splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。//sort() a-b生序排列 b-a降序排列var merge = function(nums1, m, nums2, n) { nums1.splice(m) nums2.splice(n) nums1.push(...nums2) return nums1.sort((a, b) =&gt; a - b) }; 解法02 1234var merge = function(nums1, m, nums2, n) { nums1.splice(m,n,...nums2) return nums1.sort((a,b)=&gt;a-b)};","link":"/passages/20191212-algorithm-04/"},{"title":"20191213-algorithm-05","text":"删除排序数组中的重复项 题目描述： 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 解法01： 1234567891011121314//依次比较相邻两个元素的大小//相同不做处理//不相同长度加1，同时将后一个元素赋值给前一个元素var removeDuplicates = function(nums) { if (nums.length == 0) return 0 let i = 0 for(let j = 1; j &lt;nums.length; j ++){ if (nums[i] != nums[j]){ i ++ nums[i] = nums[j] } } return i + 1}; 解法02 123456789var removeDuplicates = function(nums) { let i = 0 nums.forEach((item,index)=&gt;{ if (item !== nums[i]){ nums[++i] = item } }) return i + 1};","link":"/passages/20191213-algorithm-05/"},{"title":"20191214-algorithm-06","text":"移动零 题目 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 123示例：输入: [0,1,0,3,12]输出: [1,3,12,0,0] 解法01 123456789101112131415//1.非零数组重新排序//2.添加零元素var moveZeroes = function(nums) { if (nums.length === 0) return var k = 0 for (let i = 0; i &lt; nums.length; i ++){ if (nums[i] !== 0){ nums[k++] = nums[i] } } for (j = k ; j &lt; nums.length; j ++){ nums[j] = 0 } return nums};","link":"/passages/20191214-algorithm-06/"}],"tags":[{"name":"MQTT","slug":"MQTT","link":"/tags/MQTT/"},{"name":"K线","slug":"K线","link":"/tags/K线/"},{"name":"React Native","slug":"React-Native","link":"/tags/React-Native/"},{"name":"OneClick","slug":"OneClick","link":"/tags/OneClick/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"weekly","slug":"weekly","link":"/tags/weekly/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"ARTS打卡","slug":"ARTS打卡","link":"/categories/ARTS打卡/"},{"name":"每日","slug":"每日","link":"/categories/每日/"},{"name":"新技能get","slug":"新技能get","link":"/categories/新技能get/"},{"name":"weekly","slug":"weekly","link":"/categories/weekly/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"}]}