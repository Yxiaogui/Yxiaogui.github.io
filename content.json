{"pages":[{"title":"","text":"小目标：写16篇weekly作为开始用blog记录自己的开发之路的开始，这个目标不算大，但希望开个好头，然后坚持下去。因为并不能一上来写blog就可以做到言之有物，给人启发。因此weekly的主要内容从以下维度展开：Tips(每周开发问题)、小结(小感悟)。下一个小目标见，20191013晚10点","link":"/about/index.html"},{"title":"所有标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"ARTS打卡02","text":"TIP：极客时间：Vue:Vue cli致力于将vue生态中的工具基础标准化，他讲确保了各种构建工具能够基于智能的默认配置即可稳衔接，这样就可以专注于撰写应用，而不是纠结于配置。 Vue组件的核心概念：属性、时间、插槽。属性是单项事件流，不能再组件改变父组件传入的值。 同时学习了自定义组件，通过props传参数，点击事件回调参数等。 1234//创建vue项目1.vue create vueapp2.cd vueapp3.npm run serve OC:App启动： 首选需要了解的是：app的启动分为冷启动、热启动。app的启动主要分为三个阶段：1.main()函数执行前即pre-main()；2.main()函数执行后；3；首屏渲染完成后。 那么main()函数执行之前app 做了哪些事情呢： 123456789101.加载可执行文件,(app的.o文件)2.加载动态链接库，进行rebase指针调整和bind符号绑定。3.objc运行时的初始化处理，包括objc相关类的注册、category注册、selector唯一性检查等4.初始化，包括执行+load()方法，attribute((constructor))修改的函数的跳转、创建c++静态全局变量。//相应的对于这个阶段启动的速度优化方法有：1.减少动态库加载。2.减少加载启动后不会去使用的类或者方法3.+load()方法里面的内容可以方法首屏渲染完成之后再执行，或者使用+initialize()方法替换掉。4.控制c++全局变量的数量。//同时去看了苹果开发者大会的视频，关于性能优化之后的建议是：切换成swift，因为它足够优秀。 二维码图片保存相册:第一种： 1234567891011#import &lt;Photos/PHPhotoLibrary.h&gt;#import &lt;Photos/PHAssetChangeRequest.h&gt;[[PHPhotoLibrary sharedPhotoLibrary]performChanges:^{ [PHAssetChangeRequest creationRequestForAssetFromImage:image]; } completionHandler:^(BOOL success, NSError * _Nullable error) { if (error) { [BaseLoading showOnlyText:@&quot;保存失败&quot;]; } else { [BaseLoading showOnlyText:@&quot;保存成功&quot;]; } }]; 第二种： 12345UIGraphicsBeginImageContext(self.qrImage.size);[self.qrImage drawInRect:CGRectMake(0, 0, self.qrImage.size.width, self.qrImage.size.height)];self.qrImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();UIImageWriteToSavedPhotosAlbum(self.qrImage, nil, nil, NULL); 测试发现通过[UIImage imageWithCIImage:outImage]生产的图片需要需要第二种方法才能保存到相册。 App项目架构-VIEW：之前很少关注项目架构、代码的统一性问题；了解了设计模式代码缺写的还是很不漂亮。现在在对已有项目作调整，都是欠下的，现在需要补上。 1234561.#pragma mark life &amp;&amp; cycle2.#pragma mark - Table view data source3.#pragma mark - customeview delegate4.#pragma mark - viewmodel kvo5.#pragma mark - getters &amp;&amp; setters6.为了语义上的好理解，所有常见subview方法为customUI或者buildUI选其中之一 除了视图层的规范还需要关注网络层、缓存层、以及第三方库的管理，这个项目可能是最后一个oc项目了。 Swift:代理书写： 1234567891011//创建代理protocol NewViewControllerDelegate { func testCallBackFunc(callName:String)}//使用代理 var delegate: NewViewControllerDelegate? @objc func clickEventTap() { if self.delegate != nil { delegate?.testCallBackFunc(callName: \"nihao\") } } CSS：个人很关注css布局、定位，因为移动端上使用的autolayout有比较明显的父视图，再布局是很清楚的知道superview、subview。css在这方面的就显得比较弱，但也不是不可理解。 12345postion的6个属性：1.static(默认)静态定位；2.relative相对定位；3.absolute绝对定位；4.fixed固定位置跟绝对定位相似；5.sticky;6.inherit.偏移量:top、right、bottom 、leftfloat属性：left 、right、 none默认值，不浮动、 inherit继承父元素的浮动属性浮动会脱离正常的文档流布局，会吸附在父容器的左边或者右边等。清除浮动clear三个值：left、right、both 看了书里面对H5的布局称为容器，移动端称为视图。其实作为渲染的View来说两个的称谓可以统一。 Share:这周看了村上春树的我的职业是小说家，里面提到关于自己没有得到芥川奖的描述总结下来应该是不高估自己、心态平和、关注自己创作。","link":"/passages/20190407/"},{"title":"打卡01","text":"Algorithm：本周leetcode算法：两数之和。ps:学校的算法都还给老师了，所以要从最简单的算法训练开始.本周学习的算法是两数之和. Review:本周还没看是看英语文章 Tip:本周学习到的技巧、知识点有： CSS: html为网页构建基本的结构，而css定义了他们的外观 定义构造器的方式有：根据元素、类Class、上线文、状态等，Class的前缀是. id的前缀是# 关于盒子模型的认识，常用的参数有：padding(内边距)、border、margin、width、height、float、position、left、right等。常写app的界面布局，对于盒子模型关于父视图的认知还是有点不一样的，之前关注superview、subview等布局样式，现在需要关注left、right、float等 文档流很少关注的元素的高，高度大部分都是自动适配的，如果需要元素至少具有某一种特地高度，可以设置min-height 、max-height,同时相对应的有min-width、max-width swift本周感受最大的是学习了swift的函数方法的传参、默认值、返回值等，总体感觉比OC简单 方法名是以func开头，区别于oc 方法传入参数的是先书写形参在写实参,返回参数可以直接书写以-&gt;开头，同时可以返回多个参数，很方便，一个字：爽。 1234567891011121314151617181920212223242526func greet(person :String) -&gt; String { let greeting = \"Hello, \" + person + \"!\" return greeting} func isArray(array :[Int]) -&gt; (min :Int, max :Int) {// 判空处理 if array.isEmpty { return (0,0) } var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] { if value &lt; currentMin { currentMin = value } else if value &gt; currentMax { currentMax = value } } return (currentMin, currentMax) }// 调用如下let bounds = tom.isArray(array: [1,2,2,3545,899])print(bounds.max)print(bounds.min) 方法可以社会传入参数的默认值 123456func isDefaultString(defalutis :String = \"DASAN\") -&gt; String { return defalutis}// 调用如下let tom = Tom()print(tom.isDefaultString()) Flutter本周配置了flutter的环境：在配置环境是需要注意的问题有： 配置本地flutter路径：macos配置的flutter路径 ： /Users/haixin/flutter/flutter，最终配置的路径地址为：export PATH=/Users/haixin/flutter/flutter/bin:$PATH 路径打开、启动的方式为： 12open ~/.bash_profilesource .bash_profile 创建flutter项目的命令有： 123flutter create flutterappcd flutterappflutter run 极客时间ios专栏本周专栏从大方面来说讲了两个方面：代码的静态分析、app的无侵入埋点 代码静态分析：xcode自带有静态分析工具analyze,通过静态分析语法，可以找到代码层面的问题如内存泄露，同时也介绍了其他的三种工具：oclint、infer、clang.这三个工具都是clang库开发的。自己尝试安装、编译了infei,扫面了自己的代码。 埋点与无侵入埋点：无侵入埋点指的是在不触碰业务逻辑、高度解耦的情况下尝试对app的页面跳转、点击事件进行监控，来降低线上bug问题的处理难度。常见的方式有runtime、 category. Share:一下你内容不用看 之前的学习都是无意识的学习，所谓的无意识的学习就能学多少，学多少，这种真的是既浪费时间，有浪费空气。","link":"/passages/20190330/"},{"title":"ARTS打卡打卡03","text":"本周小结:OC:MQTT：解释：MQTT(消息队列遥测传输)是ISO 标准(ISO/IEC PRF 20922)下基于发布/订阅范式的消息协议。它工作在 TCP/IP协议族上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的发布/订阅型消息协议，为此，它需要一个消息中间件 。 本次项目用到mqtt主要使用在k线绘制，订阅K线实时数据、买卖盘数据等。 用法：用到的第三方库是阿里推荐的MQTTClient。常规参数配置如下： 12345678910111213141516171819202122232425262728- (MQTTCFSocketTransport *)transport{ if (!_transport) { _transport = [[MQTTCFSocketTransport alloc] init]; _transport.host = @&quot;your host&quot;; _transport.port = your port; } return _transport;}- (MQTTSession *)session{ if (!_session) { _session = [[MQTTSession alloc] init]; _session.userName = @&quot;your userName&quot;; _session.password = @&quot;your password&quot;; _session.clientId = @&quot;you clientId&quot;; _session.delegate = self; } return _session;}//连接- (void)connectMqtt{ self.session.transport = self.transport; [self.session connectWithConnectHandler:^(NSError *error) { if (!error) { [self.session subscribeToTopic:self.topicName atLevel:MQTTQosLevelExactlyOnce]; } }]; } 易错点： mqtt需要维持重连的。看了网上的文档有两种常规的方式。1：KVO即观察session的status；2.通过定时器，判断mqtt的状态，如果断开连接就重连。通过第一种方法观察不到status的变化，导致不能及时判断状态，因此选择了第二张方式。 mqtt关闭。需要设置self.session = nil。如果不设置只调用[self.session disconnect]，会看到mqtt日志在一直打印。因此完整的关闭mqtt的代码如下： 1234567- (void)disconnectMqtt{ [self.session unsubscribeTopic:self.topicName]; [self.session disconnect]; self.session = nil; [self.timer invalidate]; self.timer = nil;} K线：k线主要的作用是反应盘口大势状态和价格的信息，通常绘制k线需要的数据有：最高价、最低价、开盘价、收盘价、日期、成交量。 单个蜡烛图的绘制：绘制k线首先需要了解：UIBezierPath、CAShapeLayer。其中UIBezierPath指定了蜡烛图的大小位置，CAShapeLayer根据路径将蜡烛图绘制在layer上。以下是一个蜡烛图的绘制： 12345678910CGRect candleFrame = CGRectMake(313.5, 160, 5,20); UIBezierPath *path = [UIBezierPath bezierPathWithRect:candleFrame];[path moveToPoint:CGPointMake(316, 103)];[path addLineToPoint:CGPointMake(316, 160 + 20 + 7)];CAShapeLayer *layer = [CAShapeLayer layer];layer.path = path.CGPath;layer.lineWidth = 1.0f;layer.strokeColor = [UIColor redColor].CGColor;layer.fillColor = [UIColor redColor].CGColor;[self.view.layer addSublayer:layer]; web端与移动端数据问题：由于这个项目是是先开发web端先定版本，导致在移动端在使用K线数据是需要沿用web使用的数据结构。 121.web端使用数据按照日期倒叙的，移动端需要自己手动逆序数据。2.mqtt订阅主题数据的时间维度问题：每次订阅都会给出全量的时间维度数据即：1分钟、5分钟、15分钟、1小时、4小时......,每次想获取数据增量都需要遍历自己查找。 k线实时绘制：用消息队列就是K线可以实时绘制，提供准确的交易信息。在处理K线实时绘制是的一个错误的认识：每次拿到K线数据就替换之前的数据开重新绘制界面。通过对比火币的K线图发现，火币的1分钟蜡烛图只会重复绘制最后一个蜡烛图，同时实施修改蜡烛图的颜色(蜡烛图的颜色表示涨跌)，下一分钟在新增一个蜡烛图。同理5分钟、15分钟的维度也是这样绘制的。因此要以时间为参考指标来判断是否需要新增数据，代码如下： 12345678NSString *timeString = dict[@&quot;time&quot;];if ([timeString isEqualToString:oldDict[@&quot;time&quot;]]) { [self.oldklineModels replaceObjectAtIndex:0 withObject:dict]; [self.timeTypeArray addObject:dict];}else{ [self.oldklineModels insertObject:dict atIndex:0]; [self.timeTypeArray addObject:dict];} GCD:常用：1234567dispatch_async(dispatch_get_global_queue(0, 0), ^{ // 处理耗时操作的代码块... //通知主线程刷新 dispatch_async(dispatch_get_main_queue(), ^{ //回调或者说是通知主线程刷新， }); }); 12345678+ (instancetype)sharedInstance { static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance;} 什么是GCD：GCD是异步执行任务的技术之一，开发者只需要定义想要执行的任务并追加到适当的Dispatch Queue内，GCD就能生产必需的线程并计划任务执行。GCD 通过简单的方式实现了复杂的多线程编程。 ARTS:算法：极客时间：ios自动布局：常用：关不布局，最开始的时候用frame,慢慢的随着屏幕尺寸的不断新增，自动布局便成了需要被关注的点。常用的自动布局库有：Masonry、SDAutoLayout、SnapKit。其次需要了解两个单位pt、px. 学习： 1997年，Auto Layout用到的布局算法Cassowary出现。 2011年，苹果将Cassowary算法用到自动布局引擎Auto Layout。 Auto Layout的核心：Layout Engine布局引擎系统，主导整个页面布局。","link":"/passages/20190413/"},{"title":"React Native","text":"移动开发现状：1231. 原生开发2. 混合开发3. 跨平台开发 技术选型：1231.Native2.Native + H5 (1.原生与H5通过jsbridge交互，双发需要提前约定相互调用点击事件Key；2.原生通过富文本的方式渲染H5字符串)3.React-Native 、Weex 、Flutter 跨平台的优势一次编写，多平台使用，试图解决安卓、ios从交互到UI的统一。 React-Native 、Weex 、Flutter对比1.React Native 基于React 的，而React 是Facebook用户构建用户界面的Javascript库 2.Weex基于Vue的，而Vue是阿里开源的渐进式 JavaScript 框架 3.Flutter是谷歌开源的响应式框架,开发语言为Dart 4.以上可以看出RN、Weex对于前端工程师进入移动开发领域是相对友好的，而Flutter对于移动开发者、前端开发者都是有学习成本的。 5.从社区的活跃度来看RN高于Weex,而Flutter刚刚起步，但是也得到了社区的支持，因为RN是通过调用原生系统的UI组件来渲染页面，在不同的开发平台实现效果会有所偏差，毕竟是两个操作系统。而Flutter是是自有的UI框架，更接近于实现跨平台的理想。 React Native VS 原生1React Native的设计理念：既拥有Native的用户体验、又保留React的开发效率 1234567Native的优势：1.Native的原生控件有更好的体验2.Native有更好的手势识别3.Native能实现更丰富细腻的动画效果，归根结底是现阶段Native具有更好的人机交互体验Native劣势1.Native开发成本更高 综上对于开发团队在对于项目技术选型的时候需要做好平衡点：追求开发效率，还是原生体验。以此会带来对移动项目架构新的设想、实践。 React Native宣言：“Learn once, write anywhere” React Native介绍：React Native 是一个 JavaScript 的框架，用来撰写实时的、可原生呈现 iOS 和 Android 的应用。它是基于 React 的，而 React 是 Facebook 的用于构建用户界面的 JavaScript 库，但是 React Native 不是给浏览器解释的，而是为移动平台。换句话说：如果你是一名 web 开发者，你可以使用熟悉的框架和单一的 JavaScript 代码库，即 React Native来撰写清晰的、高效的移动应用。 React Native应用原理：在JavaScript中用React.js抽象操作系统的原生UI组件，继而代替DOM元素来渲染，比如使用取代，使用替代等。在后台，React Native运行在主线程之外，而在另一个专门的后台线程里运行JavaScript引擎，两个线程之间通过异步消息协议来通信。 React Native VS Flutter: React Native开发工具VSCode、WebStorm; 推荐使用VSCode VSCode需要安装的插件React Native Tools：微软官方出的ReactNative插件 path Intellisense：文件路径提示补全 Reactjs code snippets：react的代码提示 React Developer Tools：浏览器安装调试扩展 学习知识准备：了解一些基本的 React 的概念，比如 JSX 语法、组件、state状态以及props属性 JSX语法：JSX就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到&lt;，JSX就当HTML解析，遇到{就当JavaScript解析。 jsx语法：https://www.cnblogs.com/zourong/p/6043914.html 示例12345xml网上示例：&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget the meeting!&lt;/body&gt; 1234js写法var child1 = React.createElement('li', null, 'First Text Content');var child2 = React.createElement('li', null, 'Second Text Content');var root = React.createElement('ul', { className: 'my-list' }, child1, child2); 1234567等价于(JSX写法)var root =( &lt;ul className=\"my-list\"&gt; &lt;li&gt;First Text Content&lt;/li&gt; &lt;li&gt;Second Text Content&lt;/li&gt; &lt;/ul&gt;); props、State我们使用两种数据来控制一个组件：props和state。props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。 对于需要改变的数据，我们需要使用state。 一般来说，你需要在 constructor 中初始化state（译注：这是 ES6 的写法，早期的很多 ES5 的例子使用的是 getInitialState 方法来初始化 state，这一做法会逐渐被淘汰），然后在需要修改时调用setState方法。 props示例：12345_HomeListCell(item, index) { return ( &lt;HomeListCell name={item.key} index={index}&gt;&lt;/HomeListCell&gt; )} 12345678910111213class HomeListCell extends Component { constructor(props) { super(props); } render() { return ( &lt;View style={styles.listcellView}&gt; &lt;Text style={styles.listcellText}&gt;{this.props.name + this.props.index}&lt;/Text&gt; &lt;/View&gt; ) }} state示例：要点: 一切界面变化都是状态state变化 state的修改必须通过setState()方法 this.state.likes = 100; // 这样的直接赋值修改无效！ setState 是一个 merge 合并操作，只修改指定属性，不影响其他属性 setState 是异步操作，修改不会马上生效(疑问数据不是实时更新的？) 123456789101112constructor(props) { super(props); this.state = { listData: ['1','2','3'], };}_loadRequest(){ this.setState({ listData: ['3','2','1'], })} 组件：UI组件学习这个需要时间 第三方库集成：安装： npm install react-native-device-info –save 卸载： npm uninstall react-native-device-info 搜索： https://js.coach/","link":"/passages/20190617/"},{"title":"swift请求","text":"Alamofire 请求简单封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import UIKitimport Alamofireimport SwiftyJSONprotocol HTTPProxyDelegate { func httpProxySuccess(msg:String,data:NSDictionary) func httpProxyfailure(msg:String)}class HTTPProxy: NSObject { public var isPost :Bool! public var isFile :Bool! public var path = \"\" public var hosturl = \"\" private var urlString = \"\" public var parameters = [String :Any]() var delegate :HTTPProxyDelegate? let headers = [\"Sign\":\"ios\",\"Authorization\":\"1234567890\"] public func loadData() { urlString = hosturl + path if isPost { postRequest() }else{ getRequest() } } private func getRequest() { Alamofire.request(urlString, method:.get, parameters: parameters, encoding: URLEncoding() as ParameterEncoding, headers: headers).responseJSON { (response) in print(\"get request \") } } private func postRequest() { Alamofire.request(urlString, method:.post, parameters: parameters, encoding: URLEncoding() as ParameterEncoding, headers: headers).responseJSON { (responese) in if let value = responese.result.value { let jsonData = JSON(value) let code = jsonData[\"Code\"].stringValue let msg = jsonData[\"Msg\"].stringValue let data = jsonData[\"Data\"].dictionary if (code == \"200\"){ if self.delegate != nil{ self.delegate?.httpProxySuccess(msg: msg, data: data! as NSDictionary) } }else if (code == \"202\"){ if self.delegate != nil{ self.delegate?.httpProxyfailure(msg: msg) } }else{ if self.delegate != nil{ self.delegate?.httpProxyfailure(msg: msg) } } }else{ if self.delegate != nil{ self.delegate?.httpProxyfailure(msg: \"网络错误\") } } } }} 请求调用1234567891011let httpproxy = HTTPProxy()httpproxy.isPost = truehttpproxy.path = \"index/investlist\"httpproxy.delegate = selfhttpproxy.loadData()func httpProxyfailure(msg:String){}func httpProxySuccess(msg:String,data:NSDictionary){} 项目一直用的OC开发的，swift作为趋势，慢慢的需要对项目代码做迁移，OC请求封装跟swift的不同点在于：oc用的是block回调的方式，swift选择的代理。","link":"/passages/20190514/"},{"title":"cocoapods库与库依赖冲突解决","text":"集成TokenCore、web3swift.pod出现了库与库依赖版本的报错问题： 报错信息如下：123456789101112[!] CocoaPods could not find compatible versions for pod &quot;BigInt&quot;: In snapshot (Podfile.lock): BigInt (= 3.1, = 3.1.0, ~&gt; 3.1) In Podfile: TokenCore was resolved to 0.1, which depends on BigInt (= 3.0.0) web3swift.pod was resolved to 2.1.10, which depends on BigInt (~&gt; 3.1)Specs satisfying the `BigInt (= 3.1, = 3.1.0, ~&gt; 3.1), BigInt (~&gt; 3.1), BigInt (= 3.0.0)` dependency were found, but they required a higher minimum deployment target. 解决的方法如下： fork TokenCore到自己的github 修改 s.dependency “BigInt”, “3.1” 更改pod ‘TokenCore’为 pod ‘TokenCore’, git: ‘https://github.com/Yxiaogui/token-core-ios.git‘, commit: ‘c87640c72c1cf1662495cf28a90824c6731f790f’ 重新pod install 解决冲突 12pod &apos;web3swift.pod&apos;pod &apos;TokenCore&apos;, git: &apos;https://github.com/Yxiaogui/token-core-ios.git&apos;, commit: &apos;c87640c72c1cf1662495cf28a90824c6731f790f&apos; 参考文章地址：http://ju.outofmemory.cn/entry/150210","link":"/passages/20190703/"},{"title":"20190911","text":"React1231.组件化2.单向数据流 ,props state3.虚拟DOM Flex Box123通过绘制C端首页体会一次，flex布局的魅力,快速的布局瀑布流效果1.flexWrap子组件组件换行方向2.flexDirection决定组件主轴的排列方向 react-navigation12345678910111213今天比较上头的操作是设置底部tabbar的图片，难点在于接触新的的编程方式容易把之前的经验自动带入，属性赋值操作看起来就没有想象中的那么容易，方法如下：showIcon: trueHomeTab: { screen: HomeNav, navigationOptions: { tabBarLabel: &apos;首页&apos;, tabBarIcon: ({focused}) =&gt; ( focused ? &lt;Image style={styles.iconStyle} source={require(&apos;../Images/home_select.png&apos;)}/&gt; : &lt;Image style={styles.iconStyle} source={require(&apos;../Images/home_normal.png&apos;)}/&gt; ), }, },","link":"/passages/20190911/"},{"title":"制作私有仓库","text":"​ 制作私有仓库的首先需要创建一个仓库地址,名字如XXPods,这个仓库的功能是存储，里面会包换创建的各个模块如(Test-Home)的包地址。 1.创建存储仓库的过程如下：1231.pod repo add XXPods git@gitee.com:****/XXPods.git2.cd ~/.cocoapods/repos 可以看到已创建的文件3.pod repo push XXPods Test-Home.podspec --allow-warnings 制作好的包更新到自己的仓库地址 2.创建私有仓库过程如下：123451.创建仓库Test-Home,然后clone到本地2.pod spec create Test-Home, Test-Home.podspec里面会包含包版本号、仓库地址、依赖包、依赖的代码路径等。3.pod lib lint 检测仓库配置是否正确4.pod repo push XXPods Test-Home.podspec --allow-warnings 将制作好的包更新到自己的仓库地址5.使用自己的私有仓库记得在podfile文件里面加入 source &apos;https://gitee.com/****/XXPods.git’ 3.创建仓库的过程中遇到的问题：1231. 缺少LICENSE，这个可以在很多开源的仓库里看到，复制一份就解决了2. -&gt; Test-Home (0.0.1) - ERROR | [iOS] unknown: Encountered an unknown error (Malformed version number string ) during validation. 解决的方式为：sudo gem install -n /usr/local/bin cocoapods 4.更新仓库通过以上的步骤我们创建了一个Test-Home的私有库，tag等于0.0.1。可以在原有的基础上更新，但是为了业务兼容性，可能就会需要有多个tag版本同时运行，制作的方式如下 1234561.更新好本次迭代的代码内容2.pod lib lint 检测仓库配置是否正确3.注意注意更新.podspec文件的版本号4.提交代码到git5.创建tag: git tag -a 0.0.2 -m &apos;add 0.0.2&apos; 、 git push origin 0.0.26.pod repo push XXPods Test-Home.podspec --allow-warnings 将制作好的包更新到自己的仓库地址 5.podspec文件内容如下12345678910111213Pod::Spec.new do |s| s.name = &quot;Test-Home&quot; s.version = &quot;0.0.2&quot; s.summary = &quot;私人pod代码&quot; s.description = &apos;desc test home&apos; s.homepage = &quot;https://gitee.com/****&quot; s.license = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; } s.author = { &quot;张三&quot; =&gt; &quot;123456789@qq.com&quot; } s.platform = :ios, &quot;9.0&quot; s.source = { :git =&gt; &quot;https://gitee.com/*****/Test-Home.git&quot;, :tag =&gt; &quot;#{s.version}&quot; :submodules =&gt; true} s.source_files = &quot;Test-Home/*.{h,m}&quot; s.requires_arc = trueend","link":"/passages/20190704/"},{"title":"20190918","text":"React Native:关于flex 、postion的结合在移动端的布局，在C端App的实践很有效果，十几个页面写完，布局不在困难。 自定义组件传入参数，后调点击事件： 12345678910111213141516171819202122232425// 以下的自定义组件的为导航栏右侧按钮// 需要注意的是要导入 import PropTypes from &apos;prop-types&apos;;class NavRightTextView extends Component { static propTypes = { title: PropTypes.string, rightButtonClick: PropTypes.func, } static defaultProps = { title: &apos;&apos;, rightButtonClick: PropTypes.func, } _rightButtonClick() { this.props.rightButtonClick() } render() { return ( &lt;TouchableOpacity onPress={() =&gt; this._rightButtonClick()}&gt; &lt;Text style={styles.rightButton}&gt;{this.props.title}&lt;/Text&gt; &lt;/TouchableOpacity&gt; ) } Vue:vue 渐进式框架 关注视图层. 1234567891011121314151617181920212223242526272829&lt;div id=\"app\"&gt; &lt;p&gt;{{mg}}&lt;/p&gt; &lt;input v-on:input=\"inputHandle\"&gt; &lt;p v-bind:title=\"mg\"&gt;{{mg}}&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var msg = 'hello world '; //根实例 启动应用 // 传入一个对象作为参数 //{{}} 模板语法 // vue 绑定事件 /* * 指令 将数据与dom关联 v-bind 预期值是一个表达式 * v-on:事件名=\"表达式\" * */ var app = document.getElementById('app') var vm = new Vue({ // el: app el:'#app', data:{//数据对象 mg:msg, }, methods:{ inputHandle(){ console.log(\"09090\") }, } })&lt;/script&gt; Tips:123库：方法的封装，以供调用。框架： 一套架构 是一个解决方法，必须要延续使用框架定义的规范。同时要注意框架也是有复杂度的。区别在于控制权在谁手里。","link":"/passages/20190918/"},{"title":"20190910","text":"React Native项目编译：React NavigationReact Navigation库引入失败的问题，导致各种的报错，具体修复问题见官方文档提示如下：特点：容易混淆是不同版本的link的方式不同。 1231.In your project directory, run yarn add react-native-reanimated react-native-gesture-handler react-native-screens.2.React Native 0.60 and higher:linking is automatic; cd ios、pod install3.React Native 0.59 and lower；react-native link react-native-reanimated、react-native link react-native-gesture-handler、react-native link react-native-screens 编译报错编译报错内如下，特点：通过react-native run-ios 会提示报错，通过build ios app可以编译通过；错误信息如下： error Failed to build iOS project. We ran “xcodebuild” command but it exited with error code 65. To debug build logs further, consider building your app with Xcode.app, by opening ctranceplatform.xcworkspace. Run CLI with –verbose flag for more details. 123解决方法：clear build folder: &apos;Your Project&apos;/ios/buildreact-native run-ios One-Click:简介：通过运营商的接口能力直接获取用户的手机的号码。 能力输出：集成三大运营的接口能力做成SDK，以供客户使用。同时开发了One-Click应用发布应该市场，便于大家体现能力。 Tips:1.React 自定义组件命名需要首字母大写","link":"/passages/20190910/"},{"title":"第一周weekly","text":"Tips:1.React Native编译文件导致的编译失败 1234//错误提示error Failed to build iOS project. We ran &quot;xcodebuild&quot; command but it exited with error code 65://处理方法：clear build folder: &apos;Your Project&apos;/ios/build。 2.安卓真机调试：摇晃手机选择Dev，手机连接电脑本地Ip地址，例如：192.168.0.105：8081。 3.父组件向子组件传值通过props方式；子组件向父组件传值：通过props回传，涉及到组件传值，以及点击事件回调。 4.处理console.log不打印日志的问题：之前index.js文件引入了处理RN项目模拟器显示警告信息代码如下,带来的结果是调试日志打印不出来。 12console.ignoredYellowBox = ['Warning: BackAndroid is deprecated. Please use BackHandler instead.','source.uri should not be an empty string','Invalid props.style key'];console.disableYellowBox = true; 5.8081端口被占用: 1234//错误提示Connection to localhost port 8081 [tcp/sunproxyadmin] succeeded!Port 8081 already in use, packager is either not running or not running correctlyCommand PhaseScriptExecution failed with a nonzero exit code 123//解决方法sudo lsof -i :8081 kill -9 40247 6.props属性的定义错误的提示 12//这个错误出现在将设置图片的地址的props设置为string，编译器warning警告Failed prop type: Invalid prop `bgImage` of type `number` supplied to `MoneyBaseCellView`, expected `string`. 7.ios适配：逻辑分辨率适配、物理分辨率适配。 12逻辑分辨率适配：通常是基于标准机型如：iphone6的等比例尺寸的方法、缩放；另外一种是对于具体屏幕尺寸的准确布局。物理分辨率：指的是同一尺寸的像素点的多少，像素点多，分辨率高，色彩丰富，清晰度高，通常用在图片上:testImage@2x.png、estImage@3x.png。 文摘：把时间当作朋友: 每天制作你的时间预算。 很多人一生最终一事无成的原因，就是因为他们是脆弱的完美主义者，天真地希望自己可以在这个不完美的世界里完美地生存——所以注定以失败告终。 有趣的事不见得有用呢 如果，你甩甩头，强迫自己理智一些，就会知道，无用的事情，哪怕非常有趣都不应该去做；而有用的事情，哪怕非常无趣，你都应该做。 异类: 罗塞托之谜：当年主流的观点是长寿与否取决于我们是谁—也就是个体的基因，还仰赖个体做出的选择—选择吃什么，选择锻炼多长时间，以及我们受到医疗体系照顾的程度。在此之前，还从来没人从“社区”的角度研究人体健康问题。 那就是超越个人的范围寻找原因—要理解人们所处的文化背景，要考虑他们的家庭和朋友状况，要追踪其家族渊源。人们必须认识到，人类栖身其中的自然环境和社会环境，对人的发展发挥着不可磨灭的作用。 人们通常只想到杰出人士是最优质的种子，但很少想到成材还必须有充足的日照，有深厚肥沃的土壤，有足够的运气躲过兔子和伐木工人。 小结： 本周是第一次开始每晚记录自己当天的时间开销，同时记录Tips(ps:Tips是用来收集当天编码过程中出现问题或者bug的处理方式，这个作用类似于上学是老师让记得错题集)。 时间开销：记录了一周的时间开销，统计了一下当天编码的时间，3个小时左右，其中可见的很多时间都浪费了。 思考：在开始记录时间开销的第三天的时候，自己就等会对前两天的时间开销日志不忙，想着急改变。同时另外一个问题也在脑海形成：记录时间开销的时间会坚持多久？养成一个习惯的时间不会再一周之内快速养成，毕竟人的惰性还是很大的。能意识到自己时间开销浪费的正向作用是，会刺激接下来的一天、两天、三天甚至更长的天数来养成习惯，减少日常浪费时间的时间。 关于高级工程师：昨晚去招聘的网站看了一下招聘需求，看到同样年限大厂需要的是高级前端工程师，不小长需要的是编码的。对我个人的刺激点是怎么才能通向高级前端工程师，这个问题是需要我接下来四个月需要深度思考时间的问题。 第一周weekly。 下周就是国庆假期了，希望自己可以及时给自己充电。","link":"/passages/20190929/"},{"title":"第二周weekly","text":"小结： 19年的国庆节是待在杭州过的，没有回家。原因也很简单，不想被家人催的不耐烦，同时还要装出一副很体谅且无可奈何的表情。成年人的世界没有容易两字，尽可能的给自己营造舒适的生活氛围。个人感觉还是先把自己的生活过来在想其他的事情。 本周最大的收获去看完了ios视频课程，课程学完之后可能帮助我在更加全面的理解大型app的架构思想，以及个个模块的依赖关系。了解了组件化有三种方式：Tagrget-Action、Url-Scheme 、Protocol -class，推荐前两种方式。;了解了日志分级上传，ps:之前很少关注日志上传的模块的问题。在组件化思想指导下要关注以下模块：基础业务模块、日志模块、crash模块、缓存模块。 本周大部分时间还在考虑转型的问题：移动端开发者转型大前端还是后端开发？技术开发的职业生涯会有多久？自己可以做多久不会被淘汰，如果被淘汰自己是否还有其他的技能可以做备用。 其他：本周在家打扫卫生：扫地、拖地、清理汤圆的猫爬架(真的好多猫毛)。 其他假期之后的不愉快的事情都可以解决。","link":"/passages/20191006/"},{"title":"第3周weekly","text":"MacOS 10.15：本周Mac更新系统遇到的问题： 键盘的中/英切换的按钮，灯不亮了，功能还在，真的是让人不爽。 终端改为zsh,个人还是比较喜欢的，因为有很多主题可以更换，很不错的。 Pod install出错。这个网上的教程很多，更新gem源就好了。 Tips:以下是本周使用React Native开发遇到的问题： FlatList空数据渲染，ListEmptyComponent这个属性 navigationOptions不能引用this.xxx方法的问题,解决方向如下示例： 123456789101112131415161718192021222324252627282930313233//外部引用let that;class EditAddressViewController extends Component { static navigationOptions = ({navigation}) =&gt; { const params = navigation.state.params; return { title: params.NavTitle, headerRight: ( &lt;NavRightTextView title={'保存'} rightButtonClick={() =&gt; { that._addAddressRequest(); }} /&gt; ), }; }; constructor(props) { super(props); that = this; } _addAddressRequest() {} render() { return ( &lt;View style={styles.container} &lt;/View&gt; ); }} TextInput的使用问题：输入框设置固定宽度可以解决输入内容闪烁的问题、设置默认文本用defaultValue 代替 value。 静态图片的问题：Packager 就会去这个组件所在的文件夹下查找my-icon.png。并且，如果你有my-icon.ios.png和my-icon.android.png，Packager 就会根据平台而选择不同的文件。 你还可以使用@2x，@3x这样的文件名后缀，来为不同的屏幕精度提供图片。 12345// 加载远端图片 &lt;Image source={{uri: this.props.item.PicUrl}}/&gt;// 加载本地图片&lt;Image source={require('../../Images/address_edit_image.png')}/&gt; react-navigation:导航栏反向传参数的问题，示例如下: 123456789101112131415161718192021// B页面--&gt;&gt;A页面反向传参 // B页面代码_coinListTap() { this.props.navigation.state.params.callBack({ CoinId: this.props.item.CoinId, CoinName: this.props.item.CoinName, }); this.props.navigation.goBack(); }// A页面 _callBack(params) { this.setState({ coinName: params.CoinName, coinId: params.CoinId }); } _coinNameTap() { this.props.navigation.navigate('CoinListVC',{callBack:this._callBack.bind(this)}); } 小结： 本周对我个人而言有两个关键词：前端、算法。 前端是必定要涉足的领域，因为是移动端开发入行的，现在的趋势是大前端，为了提高自身的核心竞争力，必须要拥抱js、vue、react。 本周是极客大学算法训练营的预习周，下周正式开始算法的学习，希望努力学习给自己核心竞争力提供支持。努力学习是什么、为什么、怎么做的。","link":"/passages/20191013/"}],"tags":[{"name":"MQTT","slug":"MQTT","link":"/tags/MQTT/"},{"name":"K线","slug":"K线","link":"/tags/K线/"},{"name":"React Native","slug":"React-Native","link":"/tags/React-Native/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"OneClick","slug":"OneClick","link":"/tags/OneClick/"},{"name":"weekly","slug":"weekly","link":"/tags/weekly/"}],"categories":[{"name":"ARTS打卡","slug":"ARTS打卡","link":"/categories/ARTS打卡/"},{"name":"每日","slug":"每日","link":"/categories/每日/"},{"name":"新技能get","slug":"新技能get","link":"/categories/新技能get/"},{"name":"每周","slug":"每周","link":"/categories/每周/"}]}